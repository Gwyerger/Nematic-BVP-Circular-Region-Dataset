//   K( (∇.n)^2 + (n.∇xn - q)^2 + (nx∇xn)^2 ) + C( 1-(n.z)^2 )

import meshgen
import meshtools
import plot
import optimize
import vtk
import functionals

var rho = 1.5 // Deep in the nematic phase
var K = 100.0 // Bending modulus
var a2 = (1-rho)
var a4 = (1+rho)/rho^2    
var EA = 10000
var pathexport = "/mnt/c/Users/gabey/OneDrive/Desktop/Fall 2023/SM Research/Pure Cholesteric/VTK"
var initialmeshpath = pathexport
var str = "Sim n/PureCholesteric"

var R = 4
var dx = 0.2


// var memb = CircularDomain(Matrix([0,0]), R)
// var mg = MeshGen(memb, [-R..R:dx, -R..R:dx], quiet=false)
// var meshe = mg.build()
// var mesh = ChangeMeshDimension(meshe, 3)
// mesh.addgrade(1)

// var vtkME = VTKExporter(mesh)
// vtkME.export(String(initialmeshpath,"/Disk.vtk"))

var vtkMI = VTKImporter(String(initialmeshpath,"/Disk.vtk"))
var mesh = vtkMI.mesh()

var whole = Selection(mesh, fn(x,y,z) true)
var bnd = Selection(mesh, boundary=true)
var bndlayer = Selection(mesh, fn(x,y,z) x^2 + y^2 > (random()*(R - 2*dx))^2)
var interior = whole.difference(bndlayer)

bnd.addgrade(0)
bnd.addgrade(1)

// Create Defect as Selection
// fn Generate1Defect(Mesh, Wreg, Hreg) {
//     rdefect = 0.4
//     x0 = (2*random() - 1)*Wreg
//     y0 = (2*random() - 1)*Hreg
//     phid = (2*random() - 1)*Pi()
//     var Colloid = Selection(Mesh, fn(x,y,z) sqrt((x - x0)^2 + (y - y0)^2) < rdefect)
//     return x0, y0, phid, Colloid
// }

var rdefect = 1
var x0 = (2*random() - 1)*R/sqrt(2)
var y0 = (2*random() - 1)*R/sqrt(2)
var phid = (2*random() - 1)*Pi
// var phid = 0
var Colloid = Selection(mesh, fn(x,y,z) sqrt((x - x0)^2 + (y - y0)^2) < rdefect)
Colloid.addgrade(1)
Colloid.addgrade(2)

fn DefectAnchoring(x, q){
    if (x[0] > x0) {
      var phi = arctan((x[1] - y0)/(x[0] - x0))
        var wxx = sin(phid - phi/2)^2-0.5
        var wxy = cos(phid - phi/2)*sin(phid - phi/2)
        return (q[0]-wxx)^2+(q[1]-wxy)^2  
    }
    if (x[0] <= x0) {
      var phi = Pi + arctan((x[1] - y0)/(x[0] - x0))
        var wxx = sin(phid - phi/2)^2-0.5
        var wxy = cos(phid - phi/2)*sin(phid - phi/2)
        return (q[0]-wxx)^2+(q[1]-wxy)^2  
    }
}

var x1 = (2*random() - 1)*R/sqrt(2)
var y1 = (2*random() - 1)*R/sqrt(2)
var phid1 = (2*random() - 1)*Pi
// var phid1 = 0
var Colloid1 = Selection(mesh, fn(x,y,z) sqrt((x - x1)^2 + (y - y1)^2) < rdefect)
Colloid1.addgrade(1)
Colloid1.addgrade(2)

fn DefectAnchoring1(x, q){
    if (x[0] > x1) {
      var phi = arctan((x[1] - y1)/(x[0] - x1))
        var wxx = sin(phid1 - phi/2)^2-0.5
        var wxy = cos(phid1 - phi/2)*sin(phid1 - phi/2)
        return (q[0]-wxx)^2+(q[1]-wxy)^2  
    }
    if (x[0] <= x1) {
      var phi = Pi + arctan((x[1] - y1)/(x[0] - x1))
        var wxx = sin(phid1 - phi/2)^2-0.5
        var wxy = cos(phid1 - phi/2)*sin(phid1 - phi/2)
        return (q[0]-wxx)^2+(q[1]-wxy)^2  
    }
}

var q_tensor = Field(mesh, fn(x,y,z) Matrix([random()-1/2,random()-1/2]))

// // For restricting the z-component locally
// class ZCompSquared {
//     init(vec) {
//         self.vec = vec
//     }
//     integrand(vec) {
//         var int = vec.op(fn (x) x[2]^2)
//         return int.linearize().transpose()
//     }

//     fieldgradient(vec, mesh) {
//         // print vec
//         var fg = vec.op(fn (x) Matrix([0, 0, 2*x[2]]))
//         return fg
//     }

//     total(vec) {
//         return self.integrand(vec).sum()
//     }
// }

fn qtodirector(q) {
    var S = 2*q.norm()
    var Q = q/S
    var nx = sqrt(Q[0]+0.5)
    var ny = abs(Q[1]/nx)
    nx*=sign(Q[1])
    return Matrix([nx,ny,0])
}

fn qtoorder(q) {
var S = 2*q.norm()
return S
}

//Initialize a random field
// var nn = Field(mesh, fn(x,y,z) Matrix([0,sin(q*x),cos(q*x)]))  
// var nn = Field(mesh, fn(x,y,z) Matrix([2*(1/2 - random()),2*(1/2 - random()),0]))  

// var zcomp = ZCompSquared(nn)

 // Create an OptimizationProblem with our mesh as the target
var problem=OptimizationProblem(mesh) 

// Add a nematic energy functional 
// var nem = Nematic(nn, ksplay = K, ktwist = K, kbend = K, pitch = q)
// problem.addenergy(nem) 

// Add a Qtensor Functional


fn landau(x, q) {
    var qt = q.norm()
    var qt2=qt*qt
    return a2*qt2 + a4*qt2*qt2
}

fn anchoring(x, q) {
    if (x[0] > 0) {
        var phi = arctan((x[1] - 0)/(x[0] - 0))
        var phia = 0
        var ka = 2
        var wxx = sin(phia + ka*phi)^2-0.5
        var wxy = -cos(phia + ka*phi)*sin(phia + ka*phi)
        return (q[0]-wxx)^2+(q[1]-wxy)^2  
    }
    if (x[0] <= 0) {
        var phi = Pi + arctan((x[1] - 0)/(x[0] - 0))
        var phib = 0
        var kb = 2
        var wxx = sin(phib + kb*phi)^2-0.5
        var wxy = -cos(phib + kb*phi)*sin(phib + kb*phi)
        return (q[0]-wxx)^2+(q[1]-wxy)^2  
    }
}

var bulk = AreaIntegral(landau, q_tensor)
var elastic = GradSq(q_tensor)
var anchor = LineIntegral(anchoring, q_tensor)
var Defect = AreaIntegral(DefectAnchoring, q_tensor)
var Defect1 = AreaIntegral(DefectAnchoring1, q_tensor)

// problem.addenergy(bulk)

problem.addenergy(elastic, prefactor = K)
// problem.addenergy(Defect, selection=Colloid, prefactor=EA)
// problem.addenergy(Defect1, selection=Colloid1, prefactor=EA)

var problem2 = OptimizationProblem(mesh) 
problem2.addenergy(elastic, prefactor = K)

// problem.addenergy(anchor, selection=bnd, prefactor=EA)

// Unit vector constraint 
// var lnorm = NormSq(nn)                      
// problem.addlocalconstraint(lnorm, field=nn, target=1) 


// Create the field optimizer
var fopt = FieldOptimizer(problem, q_tensor)
var fopt2 = FieldOptimizer(problem2, q_tensor)
fopt.stepsize = 0.01
fopt.steplimit = 0.02
fopt.fix(interior)
fopt2.stepsize = 0.01
fopt2.steplimit = 0.02
fopt2.fix(bnd)
var vtkq = VTKExporter(q_tensor)
var nn = Field(mesh, Matrix([1,0,0]))


for (i in 0...10) {
    // vtkq.export("${pathexport}/${str}q_${i}.vtk")
    // for (i in 0...mesh.count()) nn[i]=qtodirector(q_tensor[i])
    // var vtkn = VTKExporter(nn)
    // vtkn.export("${pathexport}/${str}n_${i}.vtk")
    print(String("field optimizer ",i))
    fopt.conjugategradient(10)
}

for (i in 10...30) {
    // vtkq.export("${pathexport}/${str}q_${i}.vtk")
    // for (i in 0...mesh.count()) nn[i]=qtodirector(q_tensor[i])
    // var vtkn = VTKExporter(nn)
    // vtkn.export("${pathexport}/${str}n_${i}.vtk")
    print(String("field optimizer ",i))
    fopt2.conjugategradient(10)
}

var vtkn = VTKExporter(nn)

vtkq.export("${pathexport}/${str}q.vtk")
for (i in 0...mesh.count()) nn[i]=qtodirector(q_tensor[i])
var vtkn = VTKExporter(nn)
vtkn.export("${pathexport}/${str}n.vtk")

// var Nlevels = 0
// /* Part 6: Refinement */
// for (level in 1..Nlevels) {
//     var mr = MeshRefiner([mesh, nn, col, bnd, leftwall])
//     var refmap = mr.refine()

//     // Now refinement is done update the problems and optimizers
//     for (el in [problem, reg, sopt, fopt, ropt]) el.update(refmap)

//     // Update our references 
//     mesh = refmap[mesh]   // There are tidier ways to do this!
//     nn = refmap[nn]
//     bnd = refmap[bnd]
//     col = refmap[col]
//     leftwall = refmap[leftwall]

//     // Continue optimizing. We don't need further regularization for this particular problem
//     for (i in 1..10) {                  
//         fopt.conjugategradient(10)
//         if (fopt.hasconverged()) break 
//     }
// }
